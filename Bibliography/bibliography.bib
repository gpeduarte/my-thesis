@misc{Pereira,
   author = {Mário José and Parreira Pereira},
   title = {Tools and Techniques for the Verification of Modular Stateful Code},
   url = {https://theses.hal.science/tel-01980343v1},
}
@article{Maurica2018,
   abstract = {Runtime assertion checking aspires to a similar level of sound and complete checking of software as does static deductive verification. Furthermore, for the same source language and specification language, runtime and static checking should implement as closely as possible the same semantics. We describe here the architecture used by two different systems to achieve this goal. We accompany that with descriptions of novel designs and implementations that add new capabilities to runtime assertion checking, bringing it closer to the feature coverage of static verification.},
   author = {Fonenantsoa Maurica and David R Cok and Julien Signoles},
   doi = {10.1007/978-3-030-03421-4_6ï},
   journal = {Computer Science},
   pages = {75-91},
   title = {Runtime assertion checking and static verification: Collaborative partners},
   url = {https://cea.hal.science/cea-04477117v1},
   year = {2018},
}
@misc{Kosmatov2014,
   abstract = {Why3 is an environment for static verification, generic in the sense that it is used as an intermediate tool by different front-ends for the verification of Java, C or Ada programs. Yet, the choices made when designing the specification languages provided by those front-ends differ significantly, in particular with respect to the executability of specifications. We review these differences and the issues that result from these choices. We emphasize the specific feature of ghost code which turns out to be extremely useful for both static and dynamic verification. We also present techniques, combining static and dynamic features, that help users understand why static verification fails.},
   author = {Nikolai Kosmatov and Claude Marché and Yannick Moy and Julien Signoles},
   pages = {461-478},
   title = {Static versus Dynamic Verification in Why3, Frama-C and SPARK},
   url = {http://frama-c.com},
   year = {2014},
}
@inbook{Pereira_Ravara2021,
   abstract = {We present Cameleer, an automated deductive verification tool for OCaml. We leverage on the recently proposed GOSPEL (Generic OCaml SPEcification Language) to attach rigorous, yet readable, behavioral specification to OCaml code. The formally-specified program is fed to our toolchain, which translates it into an equivalent one in WhyML, the programming and specification language of the Why3 verification framework. We report on successful case studies conducted in Cameleer.},
   author = {Mário Pereira and António Ravara},
   doi = {10.1007/978-3-030-81688-9_31},
   editor = {Alexandra Silva and K. Rustan M. Leino},
   isbn = {978-3-030-81688-9},
   journal = {Computer Aided Verification},
   month = {7},
   pages = {677-689},
   publisher = {Springer International Publishing},
   title = {Cameleer: A Deductive Verification Tool for OCaml},
   volume = {12760},
   year = {2021},
}
@misc{,
   doi = {10.54499/UIDB/04516/2020},
   month = {1},
   title = {NOVA Laboratory for Computer Science and Informatics},
   url = {https://sciproj.ptcris.pt/157572UID},
   year = {2020},
}
@misc{Pereira2024,
   abstract = {In this paper, we provide a comprehensive, hands-on tutorial on how to apply deductive verification to programs written in OCaml. In particular, we show how one can use the GOSPEL specification language and the Cameleer tool to conduct mostly-automated verification on OCaml code. In our presentation, we focus on two main classes of programs: first, purely functional programs with no mutable state; then on imperative programs, where one can mix mutable state with subtle control-flow primitives, such as locally-defined exceptions.},
   author = {Mário Pereira},
   doi = {10.54499/UIDB/04516/2020},
   editor = {Andre Platzer and Matteo Rossi and Matteo Pradella and Kristin Yvonne Rozier},
   isbn = {978-3-031-71177-0},
   issue = {Formal Methods},
   month = {9},
   pages = {518-542},
   publisher = {Springer Nature Switzerland},
   title = {Practical Deductive Verification of OCaml Programs},
   url = {https://sciproj.ptcris.pt/157572UID},
   year = {2024},
}
@article{Rajabli2021,
   abstract = {Autonomous, or self-driving, cars are emerging as the solution to several problems primarily caused by humans on roads, such as accidents and traffic congestion. However, those benefits come with great challenges in the verification and validation (V&V) for safety assessment. In fact, due to the possibly unpredictable nature of Artificial Intelligence (AI), its use in autonomous cars creates concerns that need to be addressed using appropriate V&V processes that can address trustworthy AI and safe autonomy. In this study, the relevant research literature in recent years has been systematically reviewed and classified in order to investigate the state-of-the-art in the software V&V of autonomous cars. By appropriate criteria, a subset of primary studies has been selected for more in-depth analysis. The first part of the review addresses certification issues against reference standards, challenges in assessing machine learning, as well as general V&V methodologies. The second part investigates more specific approaches, including simulation environments and mutation testing, corner cases and adversarial examples, fault injection, software safety cages, techniques for cyber-physical systems, and formal methods. Relevant approaches and related tools have been discussed and compared in order to highlight open issues and opportunities.},
   author = {Nijat Rajabli and Francesco Flammini and Roberto Nardone and Valeria Vittorini},
   doi = {10.1109/ACCESS.2020.3048047},
   issn = {21693536},
   journal = {IEEE Access},
   keywords = {Advanced driver assistance systems,automotive engineering,autonomous vehicles,cyber-physical systems,formal verification,intelligent vehicles,machine learning,system testing,system validation,vehicle safety},
   pages = {4797-4819},
   publisher = {Institute of Electrical and Electronics Engineers Inc.},
   title = {Software Verification and Validation of Safe Autonomous Cars: A Systematic Literature Review},
   volume = {9},
   year = {2021},
}
@article{Soares2024,
   abstract = {We present our work on the collaborative use of dynamic and static analysis tools for the verification of software written in the OCaml language. We build upon Gospel, a specification language for OCaml that can be used both in dynamic and static analyses. We employ Ortac, for runtime assertion checking, and Cameleer and CFML for the deductive verification of OCaml code. We report on the use of such tools to build a case study of collaborative analysis of a non-trivial OCaml program. This shows how these tools nicely complement each others, while at the same highlights the differences when writing specification targeting dynamic or static analysis methods.},
   author = {Tiago Lopes Soares and Ion Chirica and Mário Pereira},
   month = {7},
   title = {Static and Dynamic Verification of OCaml Programs: The Gospel Ecosystem (Extended Version)},
   url = {http://arxiv.org/abs/2407.17289},
   year = {2024},
}
@misc{,
   abstract = {This paper presents experiments realized by Airbus on model checking a safety critical system, lessons learnt and ways forward to extend the industrial use of formal verification at design level.},
   author = {Thomas Bochot and Pierre Virelizier and Hélène Waeselynck and Virginie Wiels},
   title = {Model Checking Flight Control Systems: the Airbus Experience},
}
@misc{,
   abstract = {Runtime assertion checking (RAC) is a convenient set of techniques that lets developers abstract away the process of verifying the correctness of their programs by writing formal specifications and automating their verification at runtime. In this work, we present ortac, a runtime assertion checking tool for OCaml libraries and programs. OCaml is a functional programming language in which idioms rely on an expressive type system, modules, and interface abstractions. ortac consumes interfaces annotated with type invariants and function contracts and produces code wrappers with the same signature that check these specifications at runtime. It provides a flexible framework for traditional assertion checking, monitoring mis-behaviors without interruptions, and automated fuzz testing for OCaml programs. This paper presents an overview of ortac features and highlights its main design choices.},
   author = {Jean-Christophe Filliâtre and Clément Pascutto},
   keywords = {Assertion,Caml·,Checking· O,Engineer-ing,Runtime,Software},
   title = {Ortac: Runtime Assertion Checking for OCaml (tool paper)},
   url = {https://github.com/ocaml-gospel/ortac.},
}
@misc{,
   author = {Ana Cavalcanti and Manfred Broy and Tu Munich and Germany Annabelle McIver and Peter Müller and Eth Zurich and Switzerland Erik de Vink and Pamela Zave and Gerhard Goos Juris Hartmanis and Elisa Bertino and Usa Wen Gao and China Bernhard Steffen and Germany Moti Yung},
   title = {Subline Advisory Board Founding Editors Editorial Board Members},
   url = {https://link.springer.com/bookseries/558},
}
@article{Bezerra_Jonas_Santos2016,
   abstract = {Health assessment tools (treatment standardization guidelines, risk evaluation scales, disease burden estimations, and patient's perceptions questionnaires, among others) are very similar in format to a software specification, although targeted to humans. As in any document written in natural language, such medical approaches are prone to errors and misunderstandings caused by ambiguities, omissions, or inconsistencies thus reducing the applicability and efficacy of these tools. The verification of health assessment tools is an important step for standardization but it is still a manual and ad-hoc process in the medical community. This work proposes the use of a formal approach for the verification of health assessment tools. We apply and evaluate a methodology originally proposed for the verification of Use Cases to a specific medical standardization guideline. Preliminary results show that formal verification of these medical artifacts can be a cost-effective mechanism to validate and qualify health approaches.},
   author = {Jonas Santos Bezerra and Andrei Costa and Leila Ribeiro and Érika Cota},
   doi = {10.1016/j.entcs.2016.09.005},
   issn = {15710661},
   journal = {Electronic Notes in Theoretical Computer Science},
   keywords = {Formal Verification,Graph Transformations,Medical Guidelines,Textual Documents,Use Cases},
   month = {9},
   pages = {31-50},
   publisher = {Elsevier B.V.},
   title = {Formal Verification of Health Assessment Tools: a Case Study},
   volume = {324},
   year = {2016},
}
@article{Yin_Yongfeng2010,
   abstract = {As an important part of airborne avionics system, aircraft safety critical software (ASCS) plays an essential role to the safety of the aircraft, and to ensure its quality and reliability is one of the key problems we are facing. Formal methods have become important means for modeling and verifying safety critical software. In this paper, formal method is introduced into the ASCS verification field and the real-time extended finite state machine model (RT-EFSM) is studied, which includes the detailed real-time extension schemes and its validation methods. The verification process of ASCS based on RTEFSM is also proposed. Furthermore, combined with the verification of an aircraft inertial/satellite navigation systems, a timed unique input/output sequence (t_UIO) is presented and the automatic generation algorithm of subtransfer sequences based on t_UIO is given. Finally, the test adequacy criteria are discussed and a time condition coverage criterion is proposed. The actual engineering project application shows that the method proposed in this paper is of great value for the ASCS, which can be generally and effectively used in engineering. © 2010 ACADEMY PUBLISHER.},
   author = {Yongfeng Yin and Bin Liu and Duo Su},
   doi = {10.4304/jcp.5.8.1152-1159},
   issn = {1796203X},
   issue = {8},
   journal = {Journal of Computers},
   keywords = {Aircraft,Formal methods,RT-EFSM,Real-time embedded software,Safety critical software,Test sequence,Verification},
   pages = {1152-1159},
   title = {Research on formal verification technique for aircraft safety-critical software},
   volume = {5},
   year = {2010},
}
@undefined{,
}
@article{Soares_Chirica_Pereira2024,
   abstract = {We present our work on the collaborative use of dynamic and static analysis tools for the verification of software written in the OCaml language. We build upon Gospel, a specification language for OCaml that can be used both in dynamic and static analyses. We employ Ortac, for runtime assertion checking, and Cameleer and CFML for the deductive verification of OCaml code. We report on the use of such tools to build a case study of collaborative analysis of a non-trivial OCaml program. This shows how these tools nicely complement each others, while at the same highlights the differences when writing specification targeting dynamic or static analysis methods.},
   author = {Tiago Lopes Soares and Ion Chirica and Mário Pereira},
   month = {7},
   title = {Static and Dynamic Verification of OCaml Programs: The Gospel Ecosystem (Extended Version)},
   url = {http://arxiv.org/abs/2407.17289},
   year = {2024},
}
@misc{Filliatre,
   abstract = {Runtime assertion checking (RAC) is a convenient set of techniques that lets developers abstract away the process of verifying the correctness of their programs by writing formal specifications and automating their verification at runtime. In this work, we present ortac, a runtime assertion checking tool for OCaml libraries and programs. OCaml is a functional programming language in which idioms rely on an expressive type system, modules, and interface abstractions. ortac consumes interfaces annotated with type invariants and function contracts and produces code wrappers with the same signature that check these specifications at runtime. It provides a flexible framework for traditional assertion checking, monitoring mis-behaviors without interruptions, and automated fuzz testing for OCaml programs. This paper presents an overview of ortac features and highlights its main design choices.},
   author = {Jean-Christophe Filliâtre and Clément Pascutto},
   keywords = {Assertion,Caml·,Checking· O,Engineer-ing,Runtime,Software},
   title = {Ortac: Runtime Assertion Checking for OCaml (tool paper)},
   url = {https://github.com/ocaml-gospel/ortac.},
}
@inproceedings{Brian_Polgreen2025,
   abstract = {Over the past few years there has been significant progress in the various fields of software verification resulting in many useful tools and successful deployments, both academic and commercial. However much of the work describing these tools and ideas is written by and for the research community. The scale, diversity and focus of the literature can act as a barrier, separating industrial users and the wider academic community from the tools that could make their work more efficient, more certain and more productive. This tutorial gives a simple classification of verification techniques in terms of a pyramid and uses it to describe the six main schools of verification technologies. We have found this approach valuable for building collaborations with industry as it allows us to explain the intrinsic strengths and weaknesses of techniques and pick the right tool for any given industrial application. The model also highlights some of the cultural differences and unspoken assumptions of different areas of verification and illuminates future directions.},
   author = {Martin Brain and Elizabeth Polgreen},
   doi = {10.1007/978-3-031-71177-0_24},
   isbn = {9783031711763},
   issn = {16113349},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   pages = {393-419},
   publisher = {Springer Science and Business Media Deutschland GmbH},
   title = {A Pyramid Of (Formal) Software Verification},
   volume = {14934 LNCS},
   year = {2025},
}
