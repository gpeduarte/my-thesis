%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter2.tex
%% NOVA thesis document file
%%
%% Chapter with the template manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter2.tex}%

\chapter{Background}
\label{cha:background}

\textbf{NOTA:} Sections 3.3 \& 3.5; 1 \& 2 of \cite{Brian_Polgreen2025}.

\section{Formal Verification}
\label{sec:formal_verification}

Formal Verification is the process of using mathematical methods to rigorously 
prove the correctness of a software system. Its goal is to ensure that a system 
is compliant with a given set of specifications, leaving no room for ambiguities or 
unforeseen errors. Unlike traditional testing, which can only cover a 
finite set of scenarios, formal verification provides a guarantee of 
correctness for all possible inputs and states within the specified domain~\cite{Brian_Polgreen2025}.

The use of this process requires a certain level of expertise in formal methods, such as 
logical reasoning, model checking, and theorem proving. It is a complex and time-consuming 
process, but the results are proven to be worth the effort, so much so that Formal Verification 
is used in critical systems, such as avionics~\cite{Yin_Yongfeng2010}, automotive~\cite{Rajabli_Nijat2021}, 
and medical devices~\cite{Bezerra_Jonas_Santos2016}. It also helps reduce workload and costs 
of software maintenance, as it can detect and prevent errors early in the development process.

\section{OCaml}
\label{sec:ocaml}

\ocaml is a functional programming language with a strong type system and a powerful
module system. It supports imperative, functional, and object-oriented programming 
paradigms, making it a versatile choice for various types of software development. 
\ocaml's type inference system helps catch errors at compile time, reducing the 
likelihood of runtime errors and improving code reliability.

These aspects of this functional language make it a useful and resourceful tool 
for developing software that requires high standards of verification and thus, correctness.
It is language becoming more widely used for a plethora of applications.

Some of the key features of \ocaml are: its expressive type system; the pattern matching cases; 
the higher-order functions; and the module system. All these features make \ocaml an expressive 
and concise language, which can be used to develop both simple and complex systems.

\subsection{Language Overview} % (fold)
\label{sub:language_overview}

Being a functional language, \ocaml encourages the use of higher-order functions, 
which can accomodate for more generic solutions for a variety of problems. However,
\ocaml's expressive type system and powerful abstractions can lead to more robust
and maintainable code, especially in large and complex systems. The language's 
modules allow for encapsulation and organization, making code readability and organization 
easier to achieve.

As an example, consider the following code snippet, which defines a simple stack

\begin{ocamlenv}
    type 'a stack = 'a list

    let empty = []

    let push x s = x :: s

    let pop = function
        | [] -> failwith "Empty stack"
        | _ :: s -> s
\end{ocamlenv}

This code defines a stack data structure and its basic operations. It then can be used 
in a reusable manner throughout the codebase. As an example:

\begin{ocamlenv}
    let s = push 1 (push 2 empty)
    let t = pop s
\end{ocamlenv}

\todo[inline]{This code is then exemplified in the following section, should it be here?}

For programmers, it is a familiar and easy-to-understand way of defining and using 
data structures and algorithms, as they can be previously declared and used throughout 
the code.

\subsection{Modules and Functors} % (fold)
\label{sub:modules_and_functors}

Modules and functors are core features of \ocamlâ€™s type and abstraction system. 
They allow for organizing and structuring code effectively, enabling encapsulation, 
reuse, and flexibility.

A module is a collection of definitions, such as types, functions, and values, 
grouped under a single name. Modules provide namespaces to prevent naming conflicts 
and enable better code organization.

\begin{ocamlenv}
    module type Stack = sig
        type 'a t
        val empty : 'a t
        val push : 'a -> 'a t -> 'a t
        val pop : 'a t -> 'a t
    end
\end{ocamlenv}

\subsection{Higher Order Functions}
\label{sub:higher_order_functions}

Higher-order functions are functions that can take other functions as arguments 
or return them as results. They are a cornerstone of functional programming in \ocaml.
They allow 
for concise and expressive code, enabling powerful abstractions and code reuse. 
Here is an example of a higher-order function in OCaml:

\begin{ocamlenv}
    let apply_twice f x = f (f x)
\end{ocamlenv}

In this example, \texttt{apply\_twice} is a higher-order function that takes a function 
\texttt{f} and an argument \texttt{x}, and applies \texttt{f} to \texttt{x} twice.

We can also take as an example the code in the previous section, adding the \texttt{filter} 
function, taking a function as an argument:

\begin{ocamlenv}
    module type Stack = sig
        ...
        val filter : ('a -> bool) -> 'a list -> 'a list
\end{ocamlenv}

Here, the \texttt{filter} function takes a predicate function and a list, and returns 
the elements of the list that satisfy the predicate. This is an example of an Higher Order 
Function, as it takes a function as an argument.

\section{GOSPEL \& Cameleer}
\label{sec:gospel_and_cameleer}

\gospellang is a specification language built with the goal of providing \ocaml code 
with formal contracts, such as preconditions, postconditions, invariants and other 
specifications. These contracts can be used to specify the intended behavior of 
specific parts of the code~\cite{Soares_Chirica_Pereira2024}, helping to ensure correctness and reliability.

\cameleer is a tool that translates the beforementioned contracts into WhyML - 
the specification language of \why, a platform that we will talk about in 
section \ref{sec:why3}.

These tools are strongly coupled to provide a more reliable way of verifying 
\ocaml programs.

\subsection{Example}
\label{sub:example}

\todo[inline]{Add an example of a contract in GOSPEL and its translation to WhyML}

\section{Why3}
\label{sec:why3}

\ocaml in itself is a powerful language, but it lacks the tools to provide clear 
and concise specifications for the code. \why is a platform that provides a framework 
for deductive program verification. It allows for the specification of programs, 
described previously in section~\ref{sec:gospel_and_cameleer}, to be verified using 
logical verification conditions. It works with SMT solvers, such as \zthree, \altergo, 
and \coq.

\section{RAC}
\label{sec:rac}

\todo[inline]{Separation of this section into below subsections subsections}
There are several approaches to formal verification, such as static verification, 
which is based on the analysis of static code, such as type checking, and dynamic 
verification, which is based on the execution of the code, with the use of 
techniques resorting to assertions and logical contracts. Runtime Assertion Checking 
(\rac) is a dynamic verification technique that consists of inserting assertions 
into the code to check for correctness during runtime.

These assertions can be used to verify preconditions, postconditions, and invariants, 
providing a way to ensure the correctness of the code during execution. For this to 
happen, the programmer (or tester), need to insert assertions to define the intended 
behaviour of functions or modules. At runtime, these assertions are checked, and if 
any of them fail, an error is raised, indicating that the code is not behaving as 
expected.

\subsection{Technique}
\label{sub:technique}

\subsection{Relation with Static Verification}
\label{sub:relation_with_static_verification}

\subsection{ORTAC}
\label{sub:ortac}

\ortac is a tool for \rac in \ocaml programs. It provides a way to verify, at runtime, 
assertions previously declared to check if they are satisfied~\cite{Filliatre_Jean-Christophe}. If these contracts, 
defined using \why, are not met, the execution of \ortac is interrupted, and an error 
is raised, allowing the programmer or tester to evaluate the portion of code that is 
failing its logical assertion.
\todo[inline]{Add information about how ORTAC works}