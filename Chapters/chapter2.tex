%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter2.tex
%% NOVA thesis document file
%%
%% Chapter with the template manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter2.tex}%

\chapter{Background}
\label{cha:background}

\textbf{NOTA:} Sections 3.3 \& 3.5; 1 \& 2 of \cite{Brain2025}.

\section{Formal Verification}
\label{sec:formal_verification}

Formal Verification is the process of using mathematical methods to rigorously 
prove the correctness of a software system. Its goal is to ensure that a system 
is compliant with a given set of specifications, leaving no room for ambiguities or 
unforeseen errors. Unlike traditional testing, which can only cover a 
finite set of scenarios, formal verification provides a guarantee of 
correctness for all possible inputs and states within the specified domain~\cite{Brain2025}.

\section{OCaml}
\label{sec:ocaml}

\ocaml is a functional programming language with a strong type system and a powerful
module system. It supports imperative, functional, and object-oriented programming 
paradigms, making it a versatile choice for various types of software development. 
\ocaml's type inference system helps catch errors at compile time, reducing the 
likelihood of runtime errors and improving code reliability.

\subsection{Language Overview} % (fold)
\label{sub:language_overview}

Being a functional language, \ocaml encourages the use of higher-order functions, 
which can accomodate for more generic solutions for a variety of problems. However,
\ocaml's expressive type system and powerful abstractions can lead to more robust
and maintainable code, especially in large and complex systems.

\subsection{Modules and Functors} % (fold)
\label{sub:modules_and_functors}

Modules and functors are core features of \ocamlâ€™s type and abstraction system. 
They allow for organizing and structuring code effectively, enabling encapsulation, 
reuse, and flexibility.

A module is a collection of definitions, such as types, functions, and values, 
grouped under a single name. Modules provide namespaces to prevent naming conflicts 
and enable better code organization.

\begin{minted}{ocaml}
    module type Stack = sig
        type 'a t
        val empty : 'a t
        val push : 'a -> 'a t -> 'a t
        val pop : 'a t -> 'a t
        val top : 'a t -> 'a
    end
\end{minted}

\subsection{Higher Order Functions}
\label{sub:higher_order_functions}

Higher-order functions are functions that can take other functions as arguments 
or return them as results. They are a cornerstone of functional programming in \ocaml.
They allow 
for concise and expressive code, enabling powerful abstractions and code reuse. 
Here is an example of a higher-order function in OCaml:

\begin{minted}{ocaml}
    let apply_twice f x = f (f x)
\end{minted}

In this example, \texttt{apply\_twice} is a higher-order function that takes a function 
\texttt{f} and an argument \texttt{x}, and applies \texttt{f} to \texttt{x} twice.

\section{GOSPEL \& Cameleer}
\label{sec:gospel_and_cameleer}

\gospel is a specification language built with the goal of providing \ocaml code 
with formal contracts, such as preconditions, postconditions, invariants and other 
specifications. These contracts can be used to specify the intended behavior of 
specific parts of the code, helping to ensure correctness and reliability.

\cameleer is a tool that translates the beforementioned contracts into WhyML - 
the specification language of \why, a platform that we will talk about in 
section \ref{sec:why3}.

These tools are strongly coupled to provide a more reliable way of verifying 
\ocaml programs.

\subsection{Example}
\label{sub:example}

\section{Why3}
\label{sec:why3}

\ocaml in itself is a powerful language, but it lacks the tools to provide clear 
and concise specifications for the code. \why is a platform that provides a framework 
for deductive program verification. It allows for the specification of programs, 
described previously in section~\ref{sec:gospel_and_cameleer}, to be verified using 
logical verification conditions. It works with SMT solvers, such as \zthree, \altergo, 
and \coq.

\section{RAC}
\label{sec:rac}

There are several approaches to formal verification, such as static verification, 
which is based on the analysis of static code, such as type checking, and dynamic 
verification, which is based on the execution of the code, with the use of 
techniques resorting to assertions and logical contracts. Runtime Assertion Checking 
(\rac) is a dynamic verification technique that consists of inserting assertions 
into the code to check for correctness during runtime.

These assertions can be used to verify preconditions, postconditions, and invariants, 
providing a way to ensure the correctness of the code during execution. For this to 
happen, the programmer (or tester), need to insert assertions to define the intended 
behaviour of functions or modules. At runtime, these assertions are checked, and if 
any of them fail, an error is raised, indicating that the code is not behaving as 
expected.

\subsection{Technique}
\label{sub:technique}

\subsection{Relation with Static Verification}
\label{sub:relation_with_static_verification}

\section{ORTAC}
\label{sec:ortac}

\ortac is a tool for \rac in \ocaml programs. It provides a way to verify, at runtime, 
assertions previously declared to check if they are satisfied. If these contracts, 
defined using \why, are not met, the execution of \ortac is interrupted, and an error 
is raised, allowing the programmer or tester to evaluate the portion of code that is 
failing its logical assertion.